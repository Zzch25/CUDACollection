First, global accesses have been cut down to three per thread, two of which are one after the other and reads. This drastically cuts down on time since the global version accesses global memory twelve times per computation then at the end repeating an element up to nine accesses even. Access has been synchronized to get a tile so that no two or more threads must retrieve the same data per computation in a block. Also the overlap between blocks is very small. The new kernel also uses few conditional statements and no loops to minimize divergence. Finally access to memory is linear! This should help memory coalescing. 

I decided on 2D blocks. My main concern was that fetching the image in 1D would have forced the 1D threads to re-fetch more memory. For example, two 16x16 blocks are accessing memory. The overlap is 16 horizontally. As for a basic 1D, fetching vertically will cause immediate overlap between the blocks.  A 2D block however has high reuse of fetched data between threads. This was what won me over. For example, in the 1D thread, each thread can access three of the next and three of the previous threads fetches assuming they are fetching vertically. A 2D fetch can be seen by so many as nine.

My fetching works by offsetting the global memory into a shared array that includes a border for apron pixels of the block. To fetch from global, each thread accesses two offsetting by a factor of two from the first element to the end of the shared array. This causes divergence as the active threads equal (BLOCKDIM + 2)^2 / 2 which is less than BLOCKDIM^2 however seemed like an adequate trade off. If the access is outside global, nothing is written to memory. As for computing interior pixels, if the pixel was not a border pixel, its required pixels will have been fetched therefore apply the filter from the block offset into shared memory. Otherwise set to black if at the border. Nearly all of this is done computationally, but as light as possible with the exception of one modulo and divide.

